<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Hoare.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">Require Import</span> Syntax.
<span class="kn">Require Import</span> Semantics.
<span class="kn">Require Import</span> util.
<span class="kn">Require Import</span> List.
<span class="kn">Import</span> ListNotations.

<span class="kn">Instance</span> <span class="nf">LExprEq</span> : EqDec LExpr.
    <span class="nb">constructor</span>.
    <span class="bp">now</span> <span class="kp">repeat</span> <span class="bp">decide equality</span>.
<span class="kn">Defined</span>.


<span class="kn">Lemma</span> <span class="nf">terminalTerminated</span> :
    <span class="kr">forall</span> (<span class="nv">œÉ</span>:State),
    terminal (Terminated œÉ).
<span class="kn">Proof</span>.
    <span class="nb">intros</span>.
    <span class="nb">intros</span> [c&#39; H].
    <span class="nb">inversion</span> H.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">terminalAbortion</span> :
    terminal ‚ÜØ.
<span class="kn">Proof</span>.
    <span class="nb">intros</span>.
    <span class="nb">intros</span> [c&#39; H].
    <span class="nb">inversion</span> H.
<span class="kn">Qed</span>.


<span class="kn">Section</span> <span class="nf">Syntactic</span>.

    <span class="kn">Definition</span> <span class="nf">Property</span> := Expr.

    <span class="kn">Implicit Type</span> (P Q:Property) (e:Expr) (s:Stmt) (x:LExpr).

    <span class="kn">Fixpoint</span> <span class="nf">replace</span> <span class="nv">P</span> <span class="nv">e</span> <span class="nv">x</span> {<span class="nv">struct</span> <span class="nv">P</span>} :=
        <span class="kr">match</span> P <span class="kr">with</span>
        | Binary o e1 e2 =&gt; Binary o (<span class="nb">replace</span> e1 e x) (<span class="nb">replace</span> e2 e x)
        | Unary o e1 =&gt; Unary o (<span class="nb">replace</span> e1 e x)
        | LVal l =&gt; <span class="kr">if</span> eqdec l x <span class="kr">then</span> e <span class="kr">else</span> P
        | Const v =&gt; P
        <span class="kr">end</span>.

    <span class="kn">Notation</span> <span class="s2">&quot;P ‚áí Q&quot;</span> := (<span class="kr">forall</span> <span class="nv">œÉ</span>, œÉ ‚ä® P -&gt; œÉ ‚ä® Q) (<span class="kn">at level</span> <span class="mi">60</span>).

    <span class="kn">Reserved Notation</span> <span class="s2">&quot;{{ P }} s {{ Q }}&quot;</span> (<span class="kn">at level</span> <span class="mi">50</span>).
    <span class="kn">Inductive</span> <span class="nf">hoare</span> : Property -&gt; Stmt -&gt; Property -&gt; <span class="kt">Prop</span> :=
        | hoareConsequence P P&#39; s Q Q&#39;:
            (P ‚áí P&#39;) -&gt;
            (Q&#39; ‚áí Q) -&gt;
            {{P&#39;}} s {{Q&#39;}} -&gt;
            {{P}} s {{Q}}
        | hoareAssign P x e: 
            {{ <span class="nb">replace</span> P e x }} (Assign x e) {{P}}
        | hoareWhile e s P Q:
            {{Binary And P e}} s {{P}} -&gt;
            {{P}} While e s {{Binary And P (Unary Not e)}}
        | hoareIf b s1 s2 P Q:
            {{Binary And P b}} s1 {{Q}} -&gt;
            {{Binary And P (Unary Not b)}} s2 {{Q}} -&gt;
            {{P}} If b s1 s2 {{Q}}
        | hoareSkip P P:
            {{P}} Block [] {{P}}
        | hoareBlock s B P Q R:
            {{P}} s {{Q}} -&gt;
            {{Q}} Block B {{R}} -&gt;
            {{P}} Block (s::B) {{R}}
        | hoareAssert P e:
            (P ‚áí e) -&gt;
            {{P}} (Assert e) {{P}}
        | hoareAssume P e:
            {{P}} (Assume e) {{Binary And P e}}
        <span class="kn">where</span> <span class="s2">&quot;{{ P }} s {{ Q }}&quot;</span> := (hoare P s Q).
    <span class="kn">Notation</span> <span class="s2">&quot;‚ä¢ {{ P }} s {{ Q }}&quot;</span> := (hoare P s Q) (<span class="kn">at level</span> <span class="mi">50</span>).
    <span class="kn">Definition</span> <span class="nf">partial_correctness</span> <span class="nv">P</span> <span class="nv">s</span> <span class="nv">Q</span> :=
        <span class="kr">forall</span> (<span class="nv">œÉ</span>:State),
        œÉ ‚ä® P -&gt;
        <span class="kr">forall</span> (<span class="nv">c</span>:Conf),
        ‚ü® s | œÉ ‚ü© ‚áìB c -&gt;
        c ‚ä®c Q.
    <span class="kn">Notation</span> <span class="s2">&quot;‚ä® {{ P }} s {{ Q }}&quot;</span> := (partial_correctness P s Q) (<span class="kn">at level</span> <span class="mi">50</span>).

    <span class="kn">Ltac</span> <span class="nf">inv_subst</span> H :=
        <span class="nb">inversion</span> H;<span class="nb">subst</span>;<span class="nb">clear</span> H.

    <span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Import</span> <span class="nv">Equations</span>.
    <span class="kn">Require Import</span> Coq.Program.Equality.
    <span class="kn">Derive</span> <span class="nf">Signature</span> <span class="kr">for</span> properBigStep.
    <span class="kn">Derive</span> <span class="nf">Signature</span> <span class="kr">for</span> hoare.


    <span class="c">(* Lemma smallstep_bigstep_equiv s œÉ c:</span>
<span class="c">        (bigStep ‚ü®s|œÉ‚ü© c) -&gt;</span>
<span class="c">        (‚ü®s|œÉ‚ü© ‚áìB c).</span>
<span class="c">    Abort. *)</span>

    <span class="kn">Lemma</span> <span class="nf">lookup_update</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">H</span>} (<span class="nv">Œº</span>:Env A B) <span class="nv">a</span> <span class="nv">v</span>:
      @lookup A B H (Œº {a ‚Ü¶ v}) a = Some v.
    <span class="kn">Proof</span>.
      <span class="nb">unfold</span> lookup, update.
      <span class="nb">cbn</span>. <span class="nb">unfold</span> eqb. <span class="nb">destruct</span> eqdec;<span class="nb">auto</span>;<span class="bp">congruence</span>.
    <span class="kn">Qed</span>.

    <span class="kn">Lemma</span> <span class="nf">lookup_not_update</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">H</span>} (<span class="nv">Œº</span>:Env A B) <span class="nv">a</span> <span class="nv">b</span> <span class="nv">v</span>:
      a &lt;&gt; b -&gt;
      @lookup A B H (Œº {b ‚Ü¶ v}) a = @lookup A B H (Œº) a.
    <span class="kn">Proof</span>.
      <span class="nb">intros</span> Heq.
      <span class="nb">unfold</span> lookup, update.
      <span class="nb">cbn</span>. <span class="nb">unfold</span> eqb. <span class="nb">destruct</span> eqdec;<span class="bp">congruence</span>.
    <span class="kn">Qed</span>.

    <span class="kn">Lemma</span> <span class="nf">replace_subst</span> <span class="nv">P</span> <span class="nv">e</span> <span class="nv">x</span> <span class="nv">œÅ</span> <span class="nv">Œº</span> <span class="nv">a</span> <span class="nv">v</span>:
    <span class="kr">let</span> <span class="nv">œÉ</span> := (œÅ, Œº) <span class="kr">in</span>
      L‚ü¶ x ‚üß œÉ = Some a -&gt;
      R‚ü¶ e ‚üß œÉ = Some v -&gt;
      R‚ü¶ <span class="nb">replace</span> P e x ‚üß œÉ = 
      R‚ü¶ P ‚üß (œÅ, Œº {a ‚Ü¶ v}).
    <span class="kn">Proof</span>.
    <span class="nb">cbn</span>.
      <span class="nb">intros</span> Hx He.
      <span class="nb">induction</span> P.
      <span class="mi">1</span>-<span class="mi">3</span>: <span class="nb">cbn</span>.
      - <span class="bp">reflexivity</span>. <span class="c">(* Const *)</span>
      - <span class="bp">now</span> <span class="nb">rewrite</span> &lt;- IHP1, &lt;- IHP2. <span class="c">(* Binary *)</span>
      - <span class="bp">now</span> <span class="nb">rewrite</span> &lt;- IHP. <span class="c">(* Unary *)</span>
      - <span class="nb">cbn</span> [<span class="nb">replace</span>].
        <span class="nb">destruct</span> (eqdec l x) <span class="kr">as</span> [-&gt; | Hxl].
        + <span class="nb">destruct</span> x;<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="nb">unfold</span> œÅmap, Œºmap <span class="kr">in</span> *;<span class="nb">cbn</span> <span class="kr">in</span> *.
          <span class="nb">rewrite</span> He, Hx;<span class="nb">cbn</span>.
          <span class="bp">now</span> <span class="nb">rewrite</span> lookup_update;<span class="nb">cbn</span>.
        + <span class="nb">destruct</span> l,x;<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="nb">unfold</span> œÅmap, Œºmap <span class="kr">in</span> *;<span class="nb">cbn</span> <span class="kr">in</span> *.
          <span class="nb">destruct</span> (lookup _ v0) <span class="nb">eqn</span>: Hv;<span class="nb">cbn</span>;[|<span class="bp">reflexivity</span>].
    <span class="c">(* does not hold if two vars have the same address *)</span>
    <span class="kn">Abort</span>.

    <span class="kn">Lemma</span> <span class="nf">soundness</span> <span class="nv">P</span> <span class="nv">s</span> <span class="nv">Q</span>:
        ‚ä¢ {{ P }} s {{ Q }} -&gt;
        ‚ä® {{ P }} s {{ Q }}.
    <span class="kn">Proof</span>.
      <span class="nb">intros</span> H.
      <span class="nb">induction</span> H.
      - <span class="c">(* Consequence *)</span>
        <span class="nb">intros</span> œÉ HP c Hterm.
        <span class="nb">assert</span> (œÉ ‚ä® P&#39;) <span class="kr">as</span> HP&#39; <span class="bp">by</span> <span class="bp">now</span> <span class="nb">apply</span> H.
        <span class="nb">destruct</span> (IHhoare _ HP&#39; c Hterm) <span class="kr">as</span> [œÉ&#39; [-&gt; HQ&#39;]].
        <span class="bp">now</span> <span class="kr">exists</span> <span class="nv">œÉ&#39;</span>;<span class="nb">split</span>;<span class="nb">auto</span>.
      - <span class="c">(* Assign *)</span>
        <span class="nb">intros</span> œÉ HP c Hterm.
        depelim Hterm;<span class="kp">try</span> <span class="bp">congruence</span>.
        <span class="nb">eexists</span>;<span class="nb">split</span>;[<span class="bp">reflexivity</span>|].
        <span class="nb">destruct</span> HP <span class="kr">as</span> [np [Hp Hnp]].
        <span class="kr">exists</span> <span class="nv">np</span>;<span class="nb">split</span>;[|<span class="bp">assumption</span>].
        <span class="nb">admit</span>.
      - <span class="c">(* While *)</span>
        <span class="nb">intros</span> œÉ HP c.
        <span class="nb">intros</span> HWhile.
        <span class="nb">dependent induction</span> HWhile;<span class="kp">try</span> <span class="bp">congruence</span>.
        + <span class="c">(* œÉ ‚ä® e *)</span>
          <span class="nb">eapply</span> IHHWhile2.
          <span class="kp">all</span>: <span class="kp">try</span> <span class="nb">eauto</span>.
          <span class="nb">assert</span>( œÉ ‚ä® Binary And P e) <span class="kr">as</span> HPe. 
          {
            <span class="nb">destruct</span> HP <span class="kr">as</span> [np [Hp Hnp]];
            <span class="nb">destruct</span> H0 <span class="kr">as</span> [ne [He Hne]];<span class="nb">cbn</span>.
            <span class="kr">exists</span> (<span class="nv">if</span> <span class="nv">match</span> <span class="nv">np</span> <span class="nv">with</span>
            | <span class="mi">0</span> =&gt; true
            | S _ =&gt; false
            <span class="kr">end</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> ne);<span class="nb">cbn</span>;
            <span class="nb">rewrite</span> Hp, He;<span class="nb">cbn</span>;<span class="nb">split</span>;<span class="nb">auto</span>.
            <span class="nb">destruct</span> np, ne;<span class="bp">congruence</span>.
          }
          <span class="nb">specialize</span> (IHhoare _ HPe _ HWhile1).
          <span class="nb">destruct</span> IHhoare <span class="kr">as</span> [? [[= &lt;-] ?]].
          <span class="bp">assumption</span>.
        + <span class="c">(* œÉ ‚ä® ~e *)</span>
          <span class="kr">exists</span> <span class="nv">œÉ</span>;<span class="nb">split</span>;[<span class="bp">reflexivity</span>|];<span class="kr">exists</span> <span class="mi">1</span>;<span class="nb">split</span>;[|<span class="nb">auto</span>];<span class="nb">cbn</span>.
          <span class="nb">destruct</span> HP <span class="kr">as</span> [np [-&gt; Hnp]];<span class="nb">cbn</span>.
          <span class="nb">destruct</span> H0 <span class="kr">as</span> [ne [He Hne]];<span class="nb">cbn</span>.
          <span class="nb">cbn</span> <span class="kr">in</span> He.
          <span class="nb">destruct</span> (R‚ü¶ e ‚üß œÉ) <span class="kr">as</span> [[|[]]|];<span class="nb">cbn</span> <span class="kr">in</span> *.
          <span class="kp">all</span>: <span class="kp">try</span> <span class="bp">congruence</span>.
          <span class="nb">destruct</span> np;<span class="bp">tauto</span>.
        + <span class="c">(* œÉ ‚ä® e, s,œÉ ‚áì not_proper *)</span>
          <span class="nb">destruct</span> c;<span class="nb">cbn</span> <span class="kr">in</span> *.
          <span class="mi">2</span>: <span class="bp">contradict</span> H0; <span class="bp">now</span> <span class="kr">exists</span> <span class="nv">s0</span>.
          <span class="c">(* specialize Hoare IH like above *)</span>
          <span class="mi">1</span>-<span class="mi">2</span>: <span class="nb">assert</span>( œÉ ‚ä® Binary And P e) <span class="kr">as</span> HPe <span class="bp">by</span>
            ( <span class="nb">destruct</span> HP <span class="kr">as</span> [np [Hp Hnp]];
            <span class="nb">destruct</span> H1 <span class="kr">as</span> [ne [He Hne]];<span class="nb">cbn</span>;
            <span class="kr">exists</span> (<span class="nv">if</span> <span class="nv">match</span> <span class="nv">np</span> <span class="nv">with</span>
            | <span class="mi">0</span> =&gt; true
            | S _ =&gt; false
            <span class="kr">end</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> ne);<span class="nb">cbn</span>;
            <span class="nb">rewrite</span> Hp, He;<span class="nb">cbn</span>;<span class="nb">split</span>;<span class="nb">auto</span>;
            <span class="nb">destruct</span> np, ne;<span class="bp">congruence</span>);
          <span class="nb">specialize</span> (IHhoare _ HPe _ HWhile);
          <span class="bp">now</span> <span class="nb">destruct</span> IHhoare <span class="kr">as</span> [? [[= &lt;-] ?]].
      - <span class="nb">admit</span>. <span class="c">(* If *)</span>
      - <span class="nb">admit</span>. <span class="c">(* Skip *)</span>
      - <span class="nb">admit</span>. <span class="c">(* Block *)</span>
      - <span class="nb">admit</span>. <span class="c">(* Assert *)</span>
      - <span class="nb">admit</span>. <span class="c">(* Assume *)</span>
    <span class="kn">Admitted</span>.


<span class="kn">End</span> <span class="nf">Syntactic</span>.</span></pre></article></body></html>